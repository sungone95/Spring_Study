# 객체지향의 설계 5가지 원칙, SOLID 원칙

    - SRP : 단일 책임 원칙(Single responsibility principle)

    - OCP : 개방-폐쇄 원칙(Open / closed principle)

    - LSP : 리스코프 치환 원칙(Liskov substitution principle)

    - ISP : 인터페이스 분리 원칙(Interface segregation principle)

    - DIP : 의존 관계 역전 원칙(Dependency inversion principle)

---

<br>

## SRP 단일책임 원칙

- 한 클래스는 하나의 책임만 가져야한다. (모호한 표현)

- 중요한 기준은 **변경 했을 시** , 파급효과가 적을수록 단일책임원칙을 잘 따른것이다.

<BR>

## OCP 개방-폐쇄 원칙

- **확장**에는 열려있으나 **변경**에는 닫혀있어야 한다.

- 의문점: 구현객체를 변경하려면 클라이언트 코드를 변경해야한다.
  다형성을 이용해도 OCP 원칙을 지킬 수 없다.
  이것을 어떻게 해결해야하나??

  -> 객체를 생성하고, 관계를 맺어주는 별도의 **조립, 설정자**가 필요하다.
  -> 이것을 **스프링**이 해결해준다.

<BR>

## LSP 리스코프 치환 원칙

- 프로그램의 객체는 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀수 있어야한다.

- 다형성에서 하위 클래스는 인터페이스의 규약을 다 지켜야 한다는 것.
  클라이언트 입장에서 인터페이스를 믿고 사용하려면 이 원칙이 필요하다.

- EX) 자동차 인터페이스에서 엑셀은 앞으로 가라는 기능인데,
  하위 클래스에서 뒤로 가도록 구현을 한다면 LSP 위반이다.

- 쉽게 말해, 인터페이스의 큰 틀을 구현 클래스에서 벗어나면 안된다.

<BR>

## ISP 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다

- 자동차 인터페이스 -> 운전, 정비 인터페이스로 분리

- 분리하게 되면 정비 인터페이스가 변해도 운전자 클라이언트에 영향을 주지 않는다.

- 인터페이스의 본질이 명확해지고, 대체 가능성도 높아진다.

<BR>

## DIP 의존관계 역전 원칙

- 인터페이스에 의존해야하고, 구현 클래스에 의존하면 안된다.

- 앞서 얘기한 **역할**에 의존해야 한다는 것과 같다.

- 구현체에 의존하게 되면 변경이 아주 어려워진다.

- 앞서 클라이언트가 구현 클래스를 직접 선택하는 것도 DIP를 위반하는 것이다.

<BR>

## 정리

- 객체 지향의 핵심은 **다형성**

- BUT, 다형성 만으로는 쉽게 갈아 끼우듯이 개발할 수 없다.

- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함게 변경된다.

- 즉, 다형성 만으로는 OCP, DIP를 지킬 수 없다.

- 보완할 뭔가가 더 필요하다. => **SPRING**
